
	
## Формулировка задания:

Имеется корневая папка. В этой папке могут находиться текстовые файлы, а также другие папки. В других папках также могут находиться текстовые файлы и папки (уровень вложенности может оказаться любым).

 В каждом файле может быть ни одной, одна или несколько директив формата: require ‘<путь к другому файлу от корневого каталога>’ Директива означает, что текущий файл зависит от другого указанного файла. 
 
 Необходимо выявить все зависимости между файлами, построить сортированный список, для которого выполняется условие: если файл А, зависит от файла В, то файл А находится ниже файла В в списке.

 Осуществить конкатенацию файлов в соответствии со списком. Если такой список построить невозможно (существует циклическая зависимость), программа должна вывести соответствующее сообщение.
 
 
 ## Структура кода:
 
 Имеется класс File, который хранит всю информацию о файле. Методы класса позволяют устанавливать/возвращать значения переменных, характеризующих файлы. 
 
 Также основной класс Main - с функциями обхода корневой папки, прочтением всех файлов и сортировки файлов в указанном порядке с обработкой всех ошибок.
 
 ## Работа программы:
 
 Для начала в переменную $PATH`_`NAME$ запишите путь до корневой папки - из нее начнется обход.
 
 Если корневой папки не существует, программа выведет "Папки $PATH`_`NAME$ не существует". Если при обходе папки возникнет Exception, программа выведет: "При обходе дерева папок произошла ошибка"
 
 Если на данном этапе все хорошо, программа создаст объект класса File и запишет его в список всех файлов $all`_`files$, его имя в список $all`_`files`_`names$, считает сразу все его содержимое (File.content) . И выведет информацию на консоль: "Посетили файл $name`_`of`_`file$".
 
 Далее происходит чтение каждого файла: обычный текст (не require) читается и игнорируется. Как только есть require - происходит проверка на существование файла - если его не существует - записываем информацию о поломке (переменные $is`_`broken$, $broken`_`file`_`name$ и $broken`_`file`_`directory$). Если файл существует, записываем информацию о зависимости - в $File.depends`_`on$.
 
 
 Теперь нужно отсортировать файлы файлы в указанном порядке. Для этого используем топологическую сортировку - будем обходить дерево файлов поиском в глубину. Необходимая сортировка - это сортировка по убыванию времени выхода файла из рекурсии. 
 
 Также будем проверять на цикличность графа при поиске в глубину. Для этого пометим вершины (файлы) цветом: 0 - еще не заходили в вершину, 1 - зашли в вершину, но еще не вышли, 2 - уже зашли и вышли из вершины. Тогда если на очередном шаге мы зашли в вершину с цветом 1, у нас есть цикл - ставим пометку $if`_`cycle$ и файл, на котором мы заметили ошибку $file`_`cycle$.
 
 Далее происходит вывод информации на экран - обрабатываются случаи неверного указателя на файл, циклической зависимости и выводятся соответствующие сообщения на экран. При корректном задании всех файлов и отсутсвии циклов - выводятся файлы в отосртированном порядке и производится конкатенация всех текстов из файлов и их вывод на экран.
 
